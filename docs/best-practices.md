# Полезный опыт

Советы по работе с goofy и Apps Script

## Ветвление алгоритма

Алгоритм не обязан быть линейным. Если по какой-то причине не нужно обновлять плейлист, функцию можно прервать.

Предположим, есть ежедневный плейлист, который не нужно обновлять в среду. Чтобы это реализовать, напишем условие проверки. Тем самым создав ветвление кода. 

?> О работе условия `if` почитайте отдельно [здесь](https://itchief.ru/javascript/сonditional-and-logical-operators)

Ключевое слово `return` используется для возврата значения из функции. Код после этой команды никогда не выполняется. Использование `return` без возвращаемого значения - частный случай, принимающая сторона получит значение `неопределенно`. В случае запуска с триггера, это просто эквивалент того, что функция завершилась.

Пример демонстрирует, что если сегодня среда - завершаем функцию. Код после `return` не выполниться. Но если сегодня другой день недели, исполнение не попадет в ветку `if`, то есть не выполнит команду `return`, и пойдет дальше - к логике обновления плейлиста.
```js
if (Selector.isDayOfWeekRu('среда')){
    console.log('Сегодня среда. Плейлист не будет обновлен.');
    return;
}

// Логика обновления плейлиста
let tracks = Source.getPlaylistTracks('', 'id');
// ...
```

Другая ситуация. Имеем плейлист с 40 треками. Переодически слушаем его. Добавим несколько ветвлений в зависимости от количества прослушанных треков. К примеру, если не прослушано менее 10 включительно, обновим все треки. От 10 до 40 не включительно, удалим прослушанные из плейлиста. При 40 не трогаем плейлист.

```js
const ID_TARGET = 'id результата';

let tracks = Source.getPlaylistTracks('', ID_TARGET);
Filter.removeTracks(tracks, RecentTracks.get());

if (tracks.length == 40) {
    return;
} else if (tracks.length > 10 && tracks.length < 40) {
    Playlist.saveWitUpdate({
        id: ID_TARGET,
        tracks: tracks,
    });
} else {
    Playlist.saveWithReplace({
        id: ID_TARGET,
        tracks: Source.getPlaylistTracks('', 'id источника'),
    });
}
```

!> Внимательно следите за словом `length`. В нем очень просто допустить опечатку.

## Выполнение отладки

Отладка позволяет остановить выполнение кода в любом месте и проанализировать значения к этому моменту.

К примеру, нужно получить все названия треков. Но какой ключ у этого поля: `title`, `name`, `label`, `trackname`? Перебирать долго и неудобно. Выполнив отладку, увидите все доступные ключи у трека и других элементов.

?> Документация от Spotify находится [здесь](https://developer.spotify.com/documentation/web-api/reference/)

Установите точку остановки нажав рядом с номером строки, выберите функцию и нажмите `отладка`.

![Отладка](/img/fp-debug.gif)

В результате, справа откроется отладчик, где можно посмотреть промежуточные значения переменных, а также продолжить выполнение по шагам. Сверху 4 кнопки: запуск (до следующей точки или до конца), шаг с обходом, шаг с заходом внутрь и шаг с выходом изнутри. Попробуйте самостоятельно, чтобы понять на практике.

![Отладчик](/img/debuger.png)

Запуская функцию через триггер может понадобится различная информация. К примеру, какое количество треков было до и после фильтров. Для вывода подобных сообщений используйте функцию `console.log`.
```js
let tracks = Source.getSavedTracks();
console.log('Количество любимых треков', tracks.length);
```

![Пример логов](/img/example-log.png)

Решая задачу получения названия треков, выведем их следующим образом
```js
let tracks = Source.getSavedTracks();
tracks.forEach(track => console.log(track.name));
```

## Палитра команд

Палитра команд - это список действий, доступных редактору кода. Приведем некоторые полезные из них.

Установите курсор на любой строке кода и нажмите кнопку <kbd>F1</kbd> или вызовите контекстное меню правой кнопкой мыши и выберите палитру. В верхней части находится поле ввода для быстрого поиска команд. Справа от названия указываются горячие клавиши, если они доступны. Например, введите слово `шрифт`.

![Палитра команд - Шрифт](/img/cmdp-font.gif)

- Быстрое копирование. Установите курсор в любом месте строки. Зажмите клавиши <kbd>Shift</kbd><kbd>Alt</kbd> и нажимайте <kbd>↓</kbd>. Тот же эффект произойдет с выделенным фрагментом кода.
  
  ![Быстрое копирование](/img/cmdp-fast-copy.gif)

- Вертикальное выделение. Установите курсор в требуемое место. Зажмите клавиши <kbd>Shift</kbd><kbd>Alt</kbd> и проведите мышкой в противоположный угол.
  
  ![Вертикальное выделение](/img/cmdp-vertical-select.gif)

- Вертикальное выделение без мыши. Доберитесь стрелками до нужного положения. Зажмите <kbd>Ctrl</kbd><kbd>Alt</kbd> и нажимайте стрелку вверх или вниз. Теперь зажмите <kbd>Ctrl</kbd><kbd>Shift</kbd> и нажимайте стрелку вправо или влево.
  
  ![Вертикальное выделение без мыши](/img/cmdp-vertical-select-no-mouse.gif)

- Переименование. Выделите слово, например переменную, и нажмите <kbd>F2</kbd>. Все упоминания сменятся на новое имя.
  
  ![Переименование переменной](/img/cmdp-rename-f2.gif)

- Перемещение строки. Установите курсор в любое место строки. Зажмите <kbd>Alt</kbd> и нажимайте стрелку вверх или вниз. Аналогично для выделения.
  
  ![Перемещение строки](/img/cmdp-move-code.gif)

- Действие с комментарием. Установите курсор в любом месте строки, нажмите <kbd>Ctrl</kbd><kbd>/</kbd>, строка будет закомментирована. Повторное нажатие уберет комментарий. Аналогично для выделенного фрагмента.
  
  Для многострочного комментария используется комбинация <kbd>Shift</kbd><kbd>Alt</kbd><kbd>A</kbd>
  
  ![Многострочный комментарий](img/cmdp-fast-comment.gif)

- Комбинация для быстрого форматирования <kbd>Shift</kbd><kbd>Alt</kbd><kbd>F</kbd>
- Также может стать полезным сворачивание и разворачивание всего кода. Комбинации нет, ищите в палитре.

## Поиск значения

Существует несколько способов найти значение элемента. Например, жанры исполнителя или минимальную границу энергичности трека.

### Консоль Spotify

Наиболее простой способ это консоль Spotify. Надстройка, которая вызывает методы API с заданными параметрами. 

1. Зайдите в [консоль](https://developer.spotify.com/console/) и найдите необходимый метод API. Например, [исполнитель по _id_](https://developer.spotify.com/console/get-artist/).
2. Нужен токен для совершения запроса. Нажмите кнопку `get token`. В открывшемся списке, обратите внимание на примечание `not require a specific scope`. Если оно есть, просто нажмите кнопку `request token`. В противном случае, ниже примечания будет перечень чекбоксов, которые нужно прокликать. Нижний большой список не трогайте.
3. Добавьте _id_ исполнителя в поле и нажмите кнопку `try it`.

В правой части появится ответ, который дает все доступные атрибуты исполнителя. К примеру, жанры. Именно их следует использовать в [rangeTracks](/func?id=rangetracks) для `genres` или `ban_genres`
```js
"genres": [
    "candy pop",
    "emo",
    "pixie",
    "pop emo",
    "pop punk"
]
```

### Пошаговая отладка

Менее удобный способ. Во многом зависит от того, какие данные необходимо найти. 

[Выполняя отладку](/best-practices?id=Выполнение-отладки), установите точку остановки после интересуемой строки. Например, после получения списка исполнителей. Отладчик покажет массив элементов. В нем неудобно искать значение конкретного исполнителя.

![Найти жанры исполнителя](/img/find-genres.png)

### Вывод в лог

Элементы перебираются в цикле, нужная информация выводится в лог. Не подойдет для поиска данных, скрытых внутри библиотеки. Например, [особенности трека](/guide?id=Особенности-трека-features) напрямую не отдаются и функции для их получения недокументированны. Естественно допускается модификация кода библиотеки, но данный способ здесь не отражен.

```js
// Исполнитель и его жанры
artists.forEach(a => console.log(a.name, a.genres));

// Список вида: исполнитель - трек
console.log(tracks.map(t => `${t.artists[0].name} - ${t.name}`).join('\n'));
```

## Скрытие функции

Существует два способа для скрытия функций. Такую функцию нельзя запустить напрямую в редакторе кода и она не доступна для триггера.

Первый способ. Полезно для сокращения списка выбираемых функций при создании триггера. Кроме того, пример использования в [экономике триггера](/best-practices?id=Экономика-триггеров).

Добавить в конец имени нижнее подчеркивание. В примере, функция `create` доступна к запуску, а `update_` нет. 

```js
function create(){}

function update_(){}
```

- Таким способом сокрыта функция `updateRecentTracks_` (триггер для нее создан программно). 
- Функцию `doGet` скрывать не рекомендуется. Она нужна для авторизации и [управления с телефона](/addon?id=Управление-с-телефона).
- Функцию `setProperties` можно скрыть таким образом. Но при необходимости обновления параметров нужно вернуть обычное имя, чтобы получить возможность запуска в редакторе.

Второй способ. Полезно для выделения повторяющихся блоков. Например, когда разные источники требуют одинаковый набор фильтров.  

JavaScript позволяет определять функцию внутри другой. Тем самым сокращая область видимости. В примере, функция `get` доступна для вызова внутри `append`, но не видна внутри `update`. 

```js
function update(){}

function append(){

    function get(){}
}
```

## Экономика запросов

Apps Script ежедневно выдает квоту на отправку запросов - 20 тысяч. При достижении предела, невозможно получать треки, изменять плейлисты. Точное время обновления квоты неизвестно.

У функций, совершающих много запросов за один вызов, есть соответствующее примечание в [их описании](/func). Более простые функции тоже могут забрать лишнего. Основная причина в количестве треков. Например, для 1 тысячи любимых треков понадобится 10 запросов. Для 10 тысяч уже 100 запросов. Проецируя на квоту, это незначительное количество для одного дня. Поэтому бессмысленно реализовывать механизм накопления через `Cache`. Но легко совершить логические ошибки.

?> Сокращение количества запросов экономит квоту и время исполнения.

Допустим, нужно удалить любимые треки из источника и случайно отобрать десяток любимых треков для плейлиста.
```js
// Правильный вариант
let topTracks = Source.getTopTracks('long');
let savedTracks = Source.getSavedTracks();

Filter.removeTracks(topTracks, savedTracks);
Selector.keepRandom(savedTracks, 10);
```

Возможно совершить несколько ошибок. Примеры не выдуманы, они встречались в алгоритмах от пользователей goofy.
```js
// Не создавать переменную для savedTracks
// Ошибка: дважды запрос одних и тех же треков
Filter.removeTracks(topTracks, Source.getSavedTracks());
let tracks = Selector.sliceRandom(Source.getSavedTracks(), 10);

// Вызвать Selector раньше Filter
// Ошибка: из topTracks удалится не все (если конечно это не нужно специально)
Selector.keepRandom(savedTracks, 10);
Filter.removeTracks(topTracks, savedTracks);

// Пытаться исправить предыдущую ошибку
// Ошибка: снова лишние запросы
Selector.keepRandom(savedTracks, 10);
Filter.removeTracks(topTracks, Source.getSavedTracks());
```

1. Когда алгоритм требует участия одного и того же набора элементов, попробуйте изменить порядок. Как это сделано в _правильном варианте_ выше. То есть использовать полный набор везде где нужно и только потом его модифицировать.
2. Если так поступить нельзя, создайте копию вместо новых запросов. 
```js
let savedTracks = Source.getSavedTracks();
let copySavedTracks = Selector.sliceCopy(savedTracks);
```

Функция `getCountRequest` вернет значение, соответствующее тому числу запросов, которые были совершены от начала запуска до вызова функции. Значение не кэшируется. При каждом запуске отсчет начинается с нуля. Добавьте следующую строку кода в конец своей функции. Так вы сможете сравнить качество проведенной оптимизации. 
```js
console.log('Число запросов', CustomUrlFetchApp.getCountRequest());
```

При этом учитывайте влияние функций, которые способны отбирать _случайное_ количество элементов. Например, у каждого исполнителя свое количество альбомов. Поэтому в дальнейшем это повлияет на число совершенных запросов при каждом новом запуске.

## Экономика триггеров

Согласно [ограничением](/overview?id=Ограничения), на один проект (копию библиотеки) приходится 20 триггеров. При этом один всегда занят обновлением истории прослушиваний.

Предположим, что есть 3 ежедневных плейлиста. Каждая функция вызывается отдельным триггером. 

```js
function createSavedAndForgot(){}

function createDailyMix(){}

function createRecom(){}
```

Если время запуска не имеет особого значения, объединим функции. Тем самым экономя 2 триггера.
- [скроем функции](/best-practices?id=Скрытие-функции)
- удалим предыдущие триггеры
- создадим новый триггер для объединяющей функции `createEveryDayPlaylists`

```js
function createEveryDayPlaylists(){
    createSavedAndForgot_();
    createDailyMix_();
    createRecom_();
}

function createSavedAndForgot_(){}
function createDailyMix_(){}
function createRecom_(){}
```

?> При этом важно проследить за другим ограничением - временем выполнения (6 минут). Для корректной работы, время выполнения совокупности объединенных функций не должно превысить этот предел.

## keep и slice

Среди функций `Selector` есть группа, которая начинается со слов `keep` и `slice`. Когда какую использовать?

Их различие заключается в отсутствии и наличии возвращаемого значения:
- Группа `keep` вызывает внутри себя функцию `replace`. Тем самым заменяя элементы исходного массива на новые. 
- Группа `slice` не изменяет исходный массив. Создается новый массив и возвращается как результат.

```js
// Данный код
let tracks = Source.getTopTracks('long');
tracks = Selector.sliceFirst(tracks, 10);

// Эквивалентен этому
let tracks = Source.getTopTracks('long');
Selector.keepFirst(tracks, 10);
```

Тогда зачем нужно две группы? Зависит от контекста использования. С `keep` код выглядит чище. Нет постоянных приравниваний в ту же переменную.

Функции `slice` полезны для комбинирования:
```js
// Выбор в одну строку
let tracks = Selector.sliceRandom(RecentTracks.get(), 100);

// Выбор до обновления плейлиста
Playlist.saveWithReplace({
    // ...
    tracks: Selector.sliceFirst(tracks, 50),
});
```