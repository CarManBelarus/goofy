# Полезный опыт

Советы по работе с goofy и Apps Script

## Ветвление алгоритма

Алгоритм не обязан быть линейным. Если по какой-то причине не нужно обновлять плейлист, функцию можно прервать.

Предположим, есть ежедневный плейлист, который не нужно обновлять в среду. Чтобы это реализовать, напишем условие проверки. Тем самым создав ветвление кода. 

?> О работе условия `if` почитайте отдельно [здесь](https://itchief.ru/javascript/сonditional-and-logical-operators)

Ключевое слово `return` используется для возврата значения из функции. Код после этой команды никогда не выполняется. Использование `return` без возвращаемого значения - частный случай, принимающая сторона получит значение `неопределенно`. В случае запуска с триггера, это просто эквивалент того, что функция завершилась.

Пример демонстрирует, что если сегодня среда - завершаем функцию. Код после `return` не выполниться. Но если сегодня другой день недели, исполнение не попадет в ветку `if`, то есть не выполнит команду `return`, и пойдет дальше - к логике обновления плейлиста.
```js
if (Selector.isDayOfWeekRu('среда')){
    console.log('Сегодня среда. Плейлист не будет обновлен.');
    return;
}

// Логика обновления плейлиста
let tracks = Source.getPlaylistTracks('', 'id');
// ...
```

Другая ситуация. Имеем плейлист с 40 треками. Переодически слушаем его. Добавим несколько ветвлений в зависимости от количества прослушанных треков. К примеру, если не прослушано менее 10 включительно, обновим все треки. От 10 до 40 не включительно, удалим прослушанные из плейлиста. При 40 не трогаем плейлист.

```js
const ID_TARGET = 'id результата';

let tracks = Source.getPlaylistTracks('', ID_TARGET);
Filter.removeTracks(tracks, RecentTracks.get());

if (tracks.length == 40) {
    return;
} else if (tracks.length > 10 && tracks.length < 40) {
    Playlist.saveWitUpdate({
        id: ID_TARGET,
        tracks: tracks,
    });
} else {
    Playlist.saveWithReplace({
        id: ID_TARGET,
        tracks: Source.getPlaylistTracks('', 'id источника'),
    });
}
```

!> Внимательно следите за словом `length`. В нем очень просто допустить опечатку.

## Выполнение отладки

Отладка позволяет остановить выполнение кода в любом месте и проанализировать значения к этому моменту.

К примеру, нужно получить все названия треков. Но какой ключ у этого поля: `title`, `name`, `label`, `trackname`? Перебирать долго и неудобно. Выполнив отладку, увидите все доступные ключи у трека и других элементов.

?> Документация от Spotify находится [здесь](https://developer.spotify.com/documentation/web-api/reference/)

Установите точку остановки нажав рядом с номером строки, выберите функцию и нажмите `отладка`.

![Отладка](/img/fp-debug.gif)

В результате, справа откроется отладчик, где можно посмотреть промежуточные результаты, значения переменных.

![Отладчик](/img/debuger.png)

Запуская функцию через триггер может понадобится различная информация. К примеру, какое количество треков было до и после фильтров. Для вывода подобных сообщений используйте функцию `console.log`.
```js
let tracks = Source.getSavedTracks();
console.log('Количество любимых треков', tracks.length);
```

![Пример логов](/img/example-log.png)

Решая задачу получения названия треков, выведем их следующим образом
```js
let tracks = Source.getSavedTracks();
tracks.forEach(track => console.log(track.name));
```

## Скрытие функции

Существует два способа для скрытия функций. Такую функцию нельзя запустить напрямую в редакторе кода и она не доступна для триггера.

Первый способ. Полезно для сокращения списка выбираемых функций при создании триггера. Кроме того, пример использования в [экономике триггера](/best-practices?id=Экономика-триггеров).

Добавить в конец имени нижнее подчеркивание. В примере, функция `create` доступна к запуску, а `update_` нет. 

```js
function create(){}

function update_(){}
```

- Таким способом сокрыта функция `updateRecentTracks_` (триггер для нее создан программно). 
- Функцию `doGet` скрывать не рекомендуется. Она нужна для авторизации и [управления с телефона](/addon?id=Управление-с-телефона).
- Функцию `setProperties` можно скрыть таким образом. Но при необходимости обновления параметров нужно вернуть обычное имя, чтобы получить возможность запуска в редакторе.

Второй способ. Полезно для выделения повторяющихся блоков. Например, когда разные источники требуют одинаковый набор фильтров.  

JavaScript позволяет определять функцию внутри другой. Тем самым сокращая область видимости. В примере, функция `get` доступна для вызова внутри `append`, но не видна внутри `update`. 

```js
function update(){}

function append(){

    function get(){}
}
```

## Экономика запросов

Apps Script ежедневно выдает квоту на отправку запросов - 20 тысяч. При достижении предела, невозможно получать треки, изменять плейлисты. Точное время обновления квоты неизвестно.

У функций, совершающих много запросов за один вызов, есть соответствующее примечание в [их описании](/func). Более простые функции тоже могут забрать лишнего. Основная причина в количестве треков. Например, для 1 тысячи любимых треков понадобится 10 запросов. Для 10 тысяч уже 100 запросов. Проецируя на квоту, это незначительное количество для одного дня. Поэтому бессмысленно реализовывать механизм накопления через `Cache`. Но легко совершить логические ошибки.

?> Сокращение количества запросов экономит квоту и время исполнения.

Допустим, нужно удалить любимые треки из источника и случайно отобрать десяток любимых треков для плейлиста.
```js
// Правильный вариант
let topTracks = Source.getTopTracks('long');
let savedTracks = Source.getSavedTracks();

Filter.removeTracks(topTracks, savedTracks);
Selector.keepRandom(savedTracks, 10);
```

Возможно совершить несколько ошибок. Примеры не выдуманы, они встречались в алгоритмах от пользователей goofy.
```js
// Не создавать переменную для savedTracks
// Ошибка: дважды запрос одних и тех же треков
Filter.removeTracks(topTracks, Source.getSavedTracks());
let tracks = Selector.sliceRandom(Source.getSavedTracks(), 10);

// Вызвать Selector раньше Filter
// Ошибка: из topTracks удалится не все (если конечно это не нужно специально)
Selector.keepRandom(savedTracks, 10);
Filter.removeTracks(topTracks, savedTracks);

// Пытаться исправить предыдущую ошибку
// Ошибка: снова лишние запросы
Selector.keepRandom(savedTracks, 10);
Filter.removeTracks(topTracks, Source.getSavedTracks());
```

1. Когда алгоритм требует участия одного и того же набора элементов, попробуйте изменить порядок. Как это сделано в _правильном варианте_ выше. То есть использовать полный набор везде где нужно и только потом его модифицировать.
2. Если так поступить нельзя, создайте копию вместо новых запросов. 
```js
let savedTracks = Source.getSavedTracks();
let copySavedTracks = Selector.sliceCopy(savedTracks);
```

Функция `getCountRequest` вернет значение, соответствующее тому числу запросов, которые были совершены от начала запуска до вызова функции. Значение не кэшируется. При каждом запуске отсчет начинается с нуля. Добавьте следующую строку кода в конец своей функции. Так вы сможете сравнить качество проведенной оптимизации. 
```js
console.log('Число запросов', CustomUrlFetchApp.getCountRequest());
```

При этом учитывайте влияние функций, которые способны отбирать _случайное_ количество элементов. Например, у каждого исполнителя свое количество альбомов. Поэтому в дальнейшем это повлияет на число совершенных запросов при каждом новом запуске.

## Экономика триггеров

Согласно [ограничением](/overview?id=Ограничения), на один проект (копию библиотеки) приходится 20 триггеров. При этом один всегда занят обновлением истории прослушиваний.

Предположим, что есть 3 ежедневных плейлиста. Каждая функция вызывается отдельным триггером. 

```js
function createSavedAndForgot(){}

function createDailyMix(){}

function createRecom(){}
```

Если время запуска не имеет особого значения, объединим функции. Тем самым экономя 2 триггера.
- [скроем функции](/best-practices?id=Скрытие-функции)
- удалим предыдущие триггеры
- создадим новый триггер для объединяющей функции `createEveryDayPlaylists`

```js
function createEveryDayPlaylists(){
    createSavedAndForgot_();
    createDailyMix_();
    createRecom_();
}

function createSavedAndForgot_(){}
function createDailyMix_(){}
function createRecom_(){}
```

?> При этом важно проследить за другим ограничением - временем выполнения (6 минут). Для корректной работы, время выполнения совокупности объединенных функций не должно превысить этот предел.

## keep и slice

Среди функций `Selector` есть группа, которая начинается со слов `keep` и `slice`. Когда какую использовать?

Их различие заключается в отсутствии и наличии возвращаемого значения:
- Группа `keep` вызывает внутри себя функцию `replace`. Тем самым заменяя элементы исходного массива на новые. 
- Группа `slice` не изменяет исходный массив. Создается новый массив и возвращается как результат.

```js
// Данный код
let tracks = Source.getTopTracks('long');
tracks = Selector.sliceFirst(tracks, 10);

// Эквивалентен этому
let tracks = Source.getTopTracks('long');
Selector.keepFirst(tracks, 10);
```

Тогда зачем нужно две группы? Зависит от контекста использования. С `keep` код выглядит чище. Нет постоянных приравниваний в ту же переменную.

Функции `slice` полезны для комбинирования:
```js
// Выбор в одну строку
let tracks = Selector.sliceRandom(RecentTracks.get(), 100);

// Выбор до обновления плейлиста
Playlist.saveWithReplace({
    // ...
    tracks: Selector.sliceFirst(tracks, 50),
});
```