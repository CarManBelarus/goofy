# goofy  

Конструктор плейлистов Spotify. Позволяет агрегировать треки, применять фильтры и обновлять плейлисты по расписанию.

Представляет собой библиотеку JavaScript для взаимодействия [Spotify Web API](https://developer.spotify.com/documentation/web-api/) и [Google Apps Script](https://developers.google.com/apps-script). 

Обладает широкой функциональностью. Отслеживает историю прослушиваний, взаимодействует с Last.fm, позволяет импортировать треки FM-радио. Реализует все возможности сервисов [Smarter Playlists](http://smarterplaylists.playlistmachinery.com/about.html), [Playlist Miner](http://playlistminer.playlistmachinery.com/).

?> Базовое использование не требует навыков программирования. У всего есть пошаговая инструкция.

К примеру, несколько коротких алгоритмов:
- Объединить личные миксы с удалением ранее прослушанных треков
- Собирать треки из найденных по ключевым словам плейлистам
- Миксовать треки разных FM-радиостанций
- Выявлять давно непрослушиваемых треков
- Собирать новинки отслеживаемых исполнителей
- Получать рекомендации Last.fm любого пользователя
- Переносить треки с Яндекс.Музыки, в том числе любимых (лайков)

## Помощь {docsify-ignore}

При возникновении ошибки, поищите решение [здесь](/errors). Если не удается решить проблему или нужна помощь с алгоритмом создайте новую тему [на форуме](https://github.com/Chimildic/goofy/discussions).
Подробная документация о функциях доступна [здесь](/func). Перед тем как задать вопрос, пожалуйста, ознакомьтесь с ней.

## Принцип работы

Spotify API позволяет взаимодействовать с сервисом через ваш аккаунт. Тем самым получая доступ к плейлистам, любимым трекам и остальным возможностям API.

Apps Script платформа Google. Она, грубо говоря, позволяет писать макросы для остальных сервисов корпорации: документы, таблицы, диск, почта и прочее. На ряду с ними предоставляя доступ к внешним сервисам. Имеет механизм триггеров - расписание, которое определяет когда и что запустить.

Goofy это набор предопределенных функций, библиотека JavaScript. Она позволяет вам не задумываться о том, как взаимодействовать с внешними сервисами, как составлять запросы, получать результаты, модифицировать массивы треков. Черный ящик, который что-то принимает на входе и выдает результат.

Во время установки вы копируете код goofy и разрешаете этой копии работать со Spotify. Кроме вас, никто не имеет доступ к модификации кода, результатам его работы.

?> При установке или изменении версии goofy, отправляется единичный запрос в Google Формы. Чтобы иметь представление сколько пользователей активно используют библиотеку.

## Преимущества

- Бесплатное исполнение по расписанию на серверах Google
- Отслеживание [истории прослушиваний](/overview?id=История-прослушиваний)
- Доступ к истории Last.fm, топ прослушиваний за любой период
- Многообразие фильтров
- Различные способы составления рекомендаций
- Перенос треков с FM-радио, Яндекс.Музыки
- Кастомные [возможности поиска](/func?id=minetracks)
- Агрегация плейлистов малых и средних авторов

Проект легко расширить. Доступно [управление с телефона](https://github.com/Chimildic/goofy/discussions/9), внедрение своих алгоритмов. Например, [импорт с интернет-радио di.fm](https://github.com/Chimildic/goofy/discussions/57) и других источников.

## Ограничения

Библиотека подчиняется ограничениям со стороны платформ. Ниже описание конкретных показателей и на что они влияют на основе справочной информации, предлагаемой платформами.

?> При первом знакомстве некоторые детали могут быть непонятны

### Apps Script {docsify-ignore}
- Выполнение скрипта (6 минут / одно выполнение)

  - Общая максимальная продолжительность *одного* запуска скрипта. Как правило, легкие шаблоны завершаются за считанные секунды. Приблизиться к минуте или нескольким можно в случае большого объема входных и/или выходных данных.
  - Например, функция [getFollowedTracks](/func?id=getfollowedtracks) для пользователя [spotify](https://open.spotify.com/user/spotify) и аргументу `owned` в среднем отрабатывает за 4 минуты. При этом получая 1.4 тысячи плейлистов и 102 тысяч треков. После удаления дубликатов остается 78 тысяч. 
  - Если для 78 тысяч вызвать [rangeTracks](/func?id=rangetracks) лимит 6 минут будет превышен. Но предварительно отбросив заранее неподходящие треки, например, с помощью [rangeDateRel](/func?id=rangedaterel), [match](/func?id=match) и прочего, можно существенно и быстро снизить количество треков.

- Количество запросов (20 тысяч / день)

  - Как правило, 1 запрос к Spotify это получение 50 плейлистов или 50 треков. В некоторых случаях 100.
  - Пример выше получил 1.4 тысяч плейлистов и 102 тысячи треков за 1 735 запросов.
  - На получение 11 тысяч треков плейлиста 110 запросов и 25 секунд. Примерно столько же на создание плейлиста с таким количеством треков.
  - На получение 10 тысяч любимых треков уйдет 200 запросов.
  - В целом, сложно представить функцию на 20 тысяч запросов из-за ограничения 6 минут на выполнение. По этой причине можно сказать, что нельзя обойти все плейлисты роботов-пользователей с тысячами плейлистов. Но личный профиль или средних авторов можно.

- Выполнение триггеров (90 минут / день)

   - Общая максимальная продолжительность выполнения триггеров. Единственный способ достичь предела это вызвать 15 раз функцию на 6 минут за один день. Сложно представить задачу, которая потребует этого и оправдает себя. 

- Количество триггеров (20 / пользователь / скрипт)
  
   - При грубом описании это 20 плейлистов, которые создаются по совершенно *разному* расписанию. 
   - На практике, несколько функций можно вызывать из одной другой функции, что позволяет создать N плейлистов за один триггер. Подробнее [здесь](/best-practices?id=Экономика-триггеровв).
   - Кроме того, можно создать еще одну копию библиотеки и также получить квоту на 20 триггеров.
  
     > Если вам потребовалось создать еще одну копию, можете повторно использовать значения CLIENT_ID и CLIENT_SECRET и не создавать новое приложение на стороне Spotify.

Остальные ограничения Apps Script не относятся к библиотеке. Они связаны с почтой, таблицами и прочими сервисами. Или недостижимы из-за ограничений Web API Spotify. Подробнее [здесь](https://developers.google.com/apps-script/guides/services/quotas).

### Web API Spotify {docsify-ignore}
- Локальные файлы игнорируются. [API не позволяет](https://developer.spotify.com/documentation/general/guides/local-files-spotify-playlists/) добавлять такие треки в новые плейлисты и практически не несут в себе данных для фильтрации, сортировки.
  
  > It is not currently possible to add local files to playlists using the Web API, but they can be reordered or removed.

- Количество треков 
  - При добавлении в плейлист до 11 тысяч треков.
  - При получении с одного плейлиста также 11 тысяч.
  - Любимые треки до 20 тысяч.
  - При фильтрации, сортировке, выборе количество неограниченно. Но в пределах квоты Apps Script.
- Количество плейлистов
  - Теоретически до 11 тысяч, но не хватит квоты Apps Script на получение треков с них. Реальное значение в пределах 2 тысяч. Зависит от общего количества треков.
- Количество запросов
  - Точного числа нет. При слишком большом объеме запросов за короткий промежуток времени могут появиться ошибки 500, 503 и подобное. Проходят после паузы. 
  
### Google Диск {docsify-ignore}
- Размер одного текстового файла ограничен - 50 мб. Для сокращения объема можно использовать функцию [Cache.compressTracks](/func?id=compresstracks). Экспериментально удалось создать файл со 100 тысячами **сжатых** треков и уложиться в 50 мб.


## Отличия от Smarter Playlists

Главное отличие заключается в способе составления алгоритма. В Smarter Playlists визуальный язык, диаграмма. В случае Goofy используется язык программирования. Нет, изучать программирование не нужно. Достаточно скопировать предложенные шаблоны. По мере необходимости их модифицировать. Ниже пример для сравнения.

Пример создания плейлиста в Smarter Playlists. Алгоритм: взять треки из двух плейлистов, выполнить случайную сортировку, сохранить первые 50 треков в новый плейлист.

![Пример создания плейлиста в Smarter Playlists](/img/SmarterPlaylistsExample1.png)

Теперь пример того же алгоритма с помощью Goofy. Объяснение работы кода в других главах.
```js
let playlists = [
    { name: 'Микс дня 1', id: '123' },
    { name: 'Микс дня 2', id: '456' },
];

let tracks = Source.getTracks(playlists);

Order.shuffle(tracks);

Playlist.saveAsNew({
    name: 'Личный микс дня',
    tracks: Selector.sliceFirst(tracks, 50),
});
```


## История прослушиваний

Goofy автоматически отслеживает историю прослушиваний вплоть до 20 тысяч треков (значение можно увеличить) При достижении предела, новые прослушивая по-прежнему сохраняются за счет удаления самых старых. Процесс отслеживания начинается сразу после завершения настройки. Прослушивания, произошедшие до настройки не попадут в список. Однако есть способ добавить их вручную, при наличии Last.fm.

В Spotify Web API есть метод для получения истории прослушиваний. Но он позволяет получить *максимум* 50 последних треков, которые прослушаны более чем 30 секунд. В историю не попадают подкасты и треки, прослушанные в приватном режиме.

Возможность Goofy отслеживать историю появляется за счет платформы Google Apps Script и её доступа к Google Drive. Goofy переодически обращается к Spotify и обновляет содержимое файла на диске новыми данными. Теоретический период обновления равен 25 минутам (30 секунд умножить на лимит 50 треков). Практически же обновление запрашивается каждые 15 минут. Такое значение продиктовано как наиболее близкое и допустимое платформой Apps Script.

Теоретически, лимит истории можно увеличить до 100 тысяч. Но возникает вопрос производительности в рамках лимитов платформы Apps Script, доступности дискового пространства и в целом целесообразности такого массива. Поскольку в большинстве случаев такая история нужна для удаления треков из вновь создаваемых плейлистов. Задачи по составлению топа легко решаются другими средствами при наличии Last.fm.

Last.fm может [сам отслеживать](https://www.last.fm/settings/applications) прослушивания Spotify. Но все перечисленное не позволяет перехватить быстрые пропуски треков. Для этого есть два решения. Первое подробно [описано на форуме](https://www.last.fm/settings/applications). Второе заключается в том, чтобы отключить отслеживание Last.fm и использовать сторонние программы для ПК и смартфона, которые позволяют задать промежуток в несколько секунд, после которых трек сохраняется в историю. Например, [Pano Scrobbler](https://4pda.to/forum/index.php?showtopic=887068).

Рекомендуется использовать функцию [RecentTracks.get](/func?id=get).

?> На практике, Spotify API работает нестабильно. Трек после 30 секунд может вернуться с задержкой или совсем потеряться. Проблема со стороны Spotify, которая никак не решается. Однако вместе с Last.fm это становится совсем незначительным.

